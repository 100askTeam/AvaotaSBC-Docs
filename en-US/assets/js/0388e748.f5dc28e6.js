"use strict";(self.webpackChunkavaota_docs=self.webpackChunkavaota_docs||[]).push([[4925],{18199:(r,n,s)=>{s.r(n),s.d(n,{assets:()=>i,contentTitle:()=>c,default:()=>p,frontMatter:()=>a,metadata:()=>_,toc:()=>x});var e=s(85893),t=s(11151);const a={},c="SCR - \u667a\u80fd\u5361\u8bfb\u53d6\u5668",_={id:"linux-manual/amp-docs/hal/smartcard",title:"SCR - \u667a\u80fd\u5361\u8bfb\u53d6\u5668",description:"\u6a21\u5757\u4ecb\u7ecd",source:"@site/docs/linux-manual/amp-docs/hal/smartcard.md",sourceDirName:"linux-manual/amp-docs/hal",slug:"/linux-manual/amp-docs/hal/smartcard",permalink:"/en-US/linux-manual/amp-docs/hal/smartcard",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"linuxManualSidebar",previous:{title:"SID - \u552f\u4e00\u7801\u6a21\u5757",permalink:"/en-US/linux-manual/amp-docs/hal/sid"},next:{title:"SPI - \u540c\u6b65\u4e32\u884c\u63a5\u53e3",permalink:"/en-US/linux-manual/amp-docs/hal/spi"}},i={},x=[{value:"\u6a21\u5757\u4ecb\u7ecd",id:"\u6a21\u5757\u4ecb\u7ecd",level:2},{value:"\u6a21\u5757\u914d\u7f6e",id:"\u6a21\u5757\u914d\u7f6e",level:2},{value:"\u6e90\u7801\u7ed3\u6784",id:"\u6e90\u7801\u7ed3\u6784",level:2},{value:"\u6a21\u5757\u63a5\u53e3\u8bf4\u660e",id:"\u6a21\u5757\u63a5\u53e3\u8bf4\u660e",level:2},{value:"SCR \u547d\u4ee4\u679a\u4e3e",id:"scr-\u547d\u4ee4\u679a\u4e3e",level:3},{value:"SCR ATA \u6570\u636e\u7ed3\u6784\u4f53",id:"scr-ata-\u6570\u636e\u7ed3\u6784\u4f53",level:3},{value:"SMARTCARD \u521d\u59cb\u5316\u63a5\u53e3",id:"smartcard-\u521d\u59cb\u5316\u63a5\u53e3",level:3},{value:"SMARTCARD \u6d4b\u8bd5\u63a5\u53e3",id:"smartcard-\u6d4b\u8bd5\u63a5\u53e3",level:3}];function f(r){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.a)(),...r.components};return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsx)(n.h1,{id:"scr---\u667a\u80fd\u5361\u8bfb\u53d6\u5668",children:"SCR - \u667a\u80fd\u5361\u8bfb\u53d6\u5668"}),"\n",(0,e.jsx)(n.h2,{id:"\u6a21\u5757\u4ecb\u7ecd",children:"\u6a21\u5757\u4ecb\u7ecd"}),"\n",(0,e.jsx)(n.p,{children:"\u667a\u80fd\u5361\u8bfb\u53d6\u5668\uff08SCR\uff09\u662f\u4e00\u79cd\u901a\u4fe1\u63a7\u5236\u5668\uff0c\u53ef\u5728\u7cfb\u7edf\u548c\u667a\u80fd\u5361\u4e4b\u95f4\u4f20\u8f93\u6570\u636e\u3002\u63a7\u5236\u5668\u53ef\u4ee5\u6267\u884c\u5b8c\u6574\u7684\u667a\u80fd\u5361\u4f1a\u8bdd\uff0c\u5305\u62ec\u505c\u7528\u5361\u6fc0\u6d3b\u5361\uff0c\u51b7/\u70ed\u91cd\u7f6e\uff0c\u91cd\u7f6e\u5e94\u7b54\uff08ATR\uff09\u54cd\u5e94\u63a5\u6536\uff0c\u6570\u636e\u4f20\u8f93\u7b49\u3002"}),"\n",(0,e.jsx)(n.h2,{id:"\u6a21\u5757\u914d\u7f6e",children:"\u6a21\u5757\u914d\u7f6e"}),"\n",(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{children:"Kernel Setup ---\x3e\r\n    Drivers Setup ---\x3e\r\n        SoC HAL Drivers ---\x3e\r\n            smartcard devices ---\x3e\r\n                [*] enable smartcard driver\n"})}),"\n",(0,e.jsx)(n.h2,{id:"\u6e90\u7801\u7ed3\u6784",children:"\u6e90\u7801\u7ed3\u6784"}),"\n",(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:"language-c",children:"rtos-hal/\r\n|--hal/source/smartcard/scr_hal.c // hal\u5c42\u63a5\u53e3\u4ee3\u7801\n"})}),"\n",(0,e.jsx)(n.h2,{id:"\u6a21\u5757\u63a5\u53e3\u8bf4\u660e",children:"\u6a21\u5757\u63a5\u53e3\u8bf4\u660e"}),"\n",(0,e.jsx)(n.p,{children:"\u5934\u6587\u4ef6"}),"\n",(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:"language-c",children:"#include <sunxi_hal_scr.h>\n"})}),"\n",(0,e.jsx)(n.h3,{id:"scr-\u547d\u4ee4\u679a\u4e3e",children:"SCR \u547d\u4ee4\u679a\u4e3e"}),"\n",(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:"language-c",children:"enum scr_cmd {\r\n\tSCR_IOCGSTATUS = 0,\r\n\tSCR_IOCRESET,\r\n\tSCR_IOCGATR,\r\n\tSCR_IOCGPARA,\r\n\tSCR_IOCSPARA,\r\n\tSCR_IOCGATRPARA,\r\n\tSCR_IOCGPPSPARA,\r\n\tSCR_IOCWRDATA,\r\n};\n"})}),"\n",(0,e.jsx)(n.h3,{id:"scr-ata-\u6570\u636e\u7ed3\u6784\u4f53",children:"SCR ATA \u6570\u636e\u7ed3\u6784\u4f53"}),"\n",(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:"language-c",children:"struct scr_atr {\r\n\tunsigned char atr_len;\r\n\tunsigned char atr_data[MAX_ATR_LEN];\r\n};\n"})}),"\n",(0,e.jsx)(n.h3,{id:"smartcard-\u521d\u59cb\u5316\u63a5\u53e3",children:"SMARTCARD \u521d\u59cb\u5316\u63a5\u53e3"}),"\n",(0,e.jsx)(n.p,{children:"SMARTCARD \u6a21\u5757\u521d\u59cb\u5316\uff0c\u4e3b\u8981\u521d\u59cb\u5316\u91c7\u6837\u7387\u3001\u901a\u9053\u9009\u62e9\u53ca\u6ce8\u518c\u4e2d\u65ad\u7b49"}),"\n",(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:"language-c",children:"hal_scr_status_t hal_scr_init(void);\n"})}),"\n",(0,e.jsx)(n.p,{children:"\u53c2\u6570\uff1a"}),"\n",(0,e.jsxs)(n.ul,{children:["\n",(0,e.jsx)(n.li,{children:"\u65e0"}),"\n"]}),"\n",(0,e.jsx)(n.p,{children:"\u8fd4\u56de\u503c"}),"\n",(0,e.jsxs)(n.ul,{children:["\n",(0,e.jsx)(n.li,{children:"0\uff1a\u6210\u529f"}),"\n",(0,e.jsx)(n.li,{children:"\u8d1f\u6570\uff1a\u5931\u8d25"}),"\n"]}),"\n",(0,e.jsx)(n.h3,{id:"smartcard-\u6d4b\u8bd5\u63a5\u53e3",children:"SMARTCARD \u6d4b\u8bd5\u63a5\u53e3"}),"\n",(0,e.jsx)(n.p,{children:"SMARTCARD \u6a21\u5757\u529f\u80fd\u6d4b\u8bd5"}),"\n",(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:"language-c",children:"hal_scr_test(enum scr_cmd cmd, void *arg)\n"})}),"\n",(0,e.jsx)(n.p,{children:"\u53c2\u6570\uff1a"}),"\n",(0,e.jsxs)(n.ul,{children:["\n",(0,e.jsx)(n.li,{children:"cmd\uff1a\u547d\u4ee4"}),"\n",(0,e.jsx)(n.li,{children:"arg\uff1a\u53c2\u6570"}),"\n"]}),"\n",(0,e.jsx)(n.p,{children:"\u8fd4\u56de\u503c"}),"\n",(0,e.jsxs)(n.ul,{children:["\n",(0,e.jsx)(n.li,{children:"0\uff1a\u6210\u529f"}),"\n",(0,e.jsx)(n.li,{children:"\u8d1f\u6570\uff1a\u5931\u8d25"}),"\n"]}),"\n",(0,e.jsx)(n.h2,{id:""}),"\n",(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:"language-c",children:'#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <interrupt.h>\r\n#include <irqs.h>\r\n#include <string.h>\r\n#include <console.h>\r\n#include <param.h>\r\n#include <hal_osal.h>\r\n#include <hal_timer.h>\r\n#include <hal_atomic.h>\r\n#include "hal_clk.h"\r\n#include <hal_gpio.h>\r\n#include <hal_reset.h>\r\n\r\n#include <sunxi_hal_scr.h>\r\n\r\n#include "scr_test.h"\r\n\r\n#define SCR_TEST_INFO  printf\r\n#define SCR_TEST_DBG   printf\r\n#define get_wvalue\treadl\r\n#define APB2CLK\t24000000\r\n\r\nconst unsigned int SCR_REG_DEFAULT[] = {12             //reg Count\r\n\t                           ,0x00000000 ,0x000 ,0x01ff0f07   //reg 0: (default, addr, mask)\r\n\t                           ,0x00000000 ,0x004 ,0x00ff1e1f\r\n\t                           ,0x00000000 ,0x008 ,0x00ff1e1f\r\n\t                           ,0x00000101 ,0x00c ,0x00000707\r\n\t                           ,0x00000000 ,0x010 ,0x1f1f1f1f //0x1f001f1f //\r\n\t                           ,0x00000000 ,0x014 ,0x000000ff\r\n\t                           ,0x00000000 ,0x018 ,0xffffffff\r\n\t                           ,0x00000000 ,0x01c ,0x00ffffff\r\n\t                           ,0x00000000 ,0x020 ,0xffff00ff\r\n\t                           ,0x00000000 ,0x030 ,0x000000ff\r\n\t                           ,0x00000000 ,0x03c ,0xffffffff\r\n\t                           ,0x000003ff ,0x040 ,0xffffffff\r\n\t                           };\r\n\r\nconst unsigned int SCR_REG_RW[]    =   {12               //reg Count\r\n\t                           ,0x01  //Byte|Hword|Word\r\n\t                           ,0x00000000 ,0x000 ,0x01ff0007   //reg 0: (default, addr, mask)\r\n\t                           ,0x00000000 ,0x004 ,0x00ff1e1f\r\n\t                           ,0x00000000 ,0x008 ,0x00000000\r\n\t                           ,0x00000101 ,0x00c ,0x00000000\r\n\t                           ,0x00000000 ,0x010 ,0x1f1f0000 //0x1f000000 //\r\n\t                           ,0x00000000 ,0x014 ,0x000000ff\r\n\t                           ,0x00000000 ,0x018 ,0xffffffff\r\n\t                           ,0x00000000 ,0x01c ,0x00ffffff\r\n\t                           ,0x00000000 ,0x020 ,0xffff00ff\r\n\t                           ,0x00000000 ,0x030 ,0x000000fd\r\n\t                           ,0x00000000 ,0x03c ,0x00000000\r\n\t                           ,0x000003ff ,0x040 ,0xffffffff\r\n\t                           };\r\n\r\nuint8_t ic_card_atr[SMART_CARD_NUM][30] = {\r\n    { 7, 0x3b, 0x93, 0x11, 0x00, 0x00, 0x40, 0x41 }, //\u83b1\u897f\u6709\u7ebf\r\n    { 18, 0x3b, 0x7d, 0x94, 0x00, 0x00, 0x57, 0x44, 0x53, 0x67, 0x96, 0x86,\r\n        0x93, 0x03, 0x9d, 0xf7, 0x10, 0x00, 0x9d }, //\u795e\u5dde\u5927\u4f17\u53611\r\n    { 15, 0x3b, 0xb9, 0x94, 0x00, 0x40, 0x14, 0x47, 0x47, 0x33, 0x53, 0x30,\r\n        0x35, 0x41, 0x53, 0x30 }, //\u795e\u5dde\u5927\u4f17\u53612\r\n    { 17, 0x3b, 0x9d, 0x95, 0x00, 0x13, 0x61, 0x40, 0x36, 0x13, 0x85, 0xe9,\r\n        0x44, 0x34, 0x8f, 0x78, 0x8f, 0x4a }, //\u6570\u5b57\u7535\u89c6\u53611\r\n    { 17, 0x3b, 0x9d, 0x95, 0x00, 0x13, 0x61, 0x40, 0x36, 0x13, 0x85, 0xe9,\r\n        0x44, 0x34, 0xf3, 0x78, 0x8f, 0x4a }, //\u6570\u5b57\u7535\u89c6\u53612\r\n    {\r\n        22, 0x3b, 0x9f, 0x95, 0x80, 0x1f, 0xc3, 0x80,\r\n        0x31, 0xe0, 0x73, 0xfe, 0x21, 0x13, 0x57, 0x86,\r\n        0x81, 0x02, 0x86, 0x98, 0x44, 0x18, 0xa8 }, //\u7535\u4fe14G\u5361\r\n    { 20, 0x3b, 0xfb, 0x94, 0x00, 0x00, 0x80, 0x1f, 0x83, 0x80, 0x65,\r\n        0x92, 0x10, 0x26, 0x86, 0x53, 0x83, 0x00, 0x90, 0x00, 0xf4 }, //\u8054\u901a\u5361\r\n    { 16, 0x3b, 0x7b, 0x94, 0x00, 0x00, 0x97, 0x88, 0x84, 0x86, 0x60, 0xa0,\r\n        0x04, 0x01, 0x00, 0x04, 0x00 }, //\u79fb\u52a8\u5361\r\n    { 20, 0x3b, 0x7f, 0x12, 0x00, 0x00, 0x44, 0x56, 0x4e, 0x20, 0x54,\r\n        0x45, 0x53, 0x54, 0x20, 0x43, 0x41, 0x52, 0x44, 0x76, 0x31 } // digital\r\n    // TV\u5361\r\n};\r\n\r\nuint8_t ic_card_send_cmd[SMART_CARD_NUM][30] = {\r\n    { 5, 0xe5, 0x04, 0x00, 0x00, 0x04 }, //\u83b1\u897f\u6709\u7ebf\r\n    { 0 },\r\n    { 0 },\r\n    { 0 },\r\n    { 0 },\r\n    { 0 },\r\n    { 0 },\r\n    { 7, 0xA0, 0xA4, 0x00, 0x00, 0x02, 0x3F, 0x00 }, //\u79fb\u52a8\u5361\r\n    { 0 }\r\n};\r\n\r\nuint8_t ic_card_rev_data[SMART_CARD_NUM][30] = {\r\n    { 7, 0x04, 0x4d, 0x33, 0x4f, 0x4b, 0x90, 0x00 }, //\u83b1\u897f\u6709\u7ebf\r\n    { 0 },\r\n    { 0 },\r\n    { 0 },\r\n    { 0 },\r\n    { 0 },\r\n    { 0 },\r\n    { 3, 0xa4, 0x9f, 0x1b }, //\u79fb\u52a8\u5361\r\n    { 0 }\r\n};\r\n\r\nscr_struct scr;\r\nscr_fsm_record scr_fsm;\r\nscatr_struct scatr;\r\nupps_struct pps;\r\n\r\nextern scr_test_stage stage;\r\nstatic int state_dly = 0x0;\r\n\r\n#define SCR_SIM_DBG(x) pattern_mod_goto(0x2, x)\r\n\r\nvoid scr_ccu_clk_gate_on(u32 sel)\r\n{\r\n    int ret;\r\n    ret = readl(0x4003c004);\r\n    hal_write_reg32(0x4003c004, 0x4000000 | ret);\r\n}\r\n\r\nvoid scr_ccu_clk_gate_off(u32 sel)\r\n{\r\n    int ret;\r\n    ret = readl(0x4003c004);\r\n    hal_write_reg32(0x4003c004, 0xfbffffff & ret);\r\n}\r\n\r\nvoid scr_module_rst_on(u32 sel)\r\n{\r\n    int ret;\r\n    ret = readl(0x4003c00c);\r\n    hal_write_reg32(0x4003c00c, 0x4000000 | ret);\r\n}\r\n\r\nvoid scr_module_rst_off(u32 sel)\r\n{\r\n    int ret;\r\n    ret = readl(0x4003c00c);\r\n    hal_write_reg32(0x4003c00c, 0xfbffffff & ret);\r\n}\r\n\r\nvoid scr_module_rst(u32 sel)\r\n{\r\n    scr_module_rst_off(sel);\r\n    udelay(300);\r\n    scr_module_rst_on(sel);\r\n    udelay(300);\r\n}\r\n\r\nvoid scr_pio_setup(void)\r\n{\r\n    int ret;\r\n    ret = hal_gpio_pinmux_set_function(GPIOA(14), 5);\r\n    if (ret) {\r\n        printf("scr pin set function failed\\n");\r\n        return -1;\r\n    }\r\n}\r\n\r\n/* Configure the CCMU Clock & De-assert Reset & Gating & GPIO configure */\r\nvoid scr_system_setup(u32 sel)\r\n{\r\n    scr_module_rst_off(sel);\r\n    scr_ccu_clk_gate_off(sel);\r\n    udelay(300);\r\n    scr_ccu_clk_gate_on(sel); /*enable APB clock*/\r\n    scr_module_rst_on(sel);\r\n    scr_pio_setup(); /*IO configure*/\r\n}\r\n\r\nuint32_t\r\nscr_reg_test(void) // registers default values cheak and read write check\r\n{\r\n    uint32_t temp;\r\n\r\n    scr_module_rst(SCR_NO);\r\n    SCR_TEST_INFO("SCR Register Test Pass!!\\n");\r\n    return 1;\r\n}\r\n\r\nstatic hal_irqreturn_t scr0_irq_handler(void* dev)\r\n{\r\n    scr_handler_irq(&scr);\r\n\r\n    return 0;\r\n}\r\n\r\nvoid reg_scr0_irq_handler(void)\r\n{\r\n    hal_request_irq(scr.irq_no, scr0_irq_handler, "scr0", &scr);\r\n    hal_enable_irq(scr.irq_no);\r\n}\r\n\r\nvoid scr_params_init(void)\r\n{\r\n    scr.reg_base = 0x40045400;\r\n\r\n    scr.irq_no = 69; //\u4e2d\u65ad\u53f7\r\n    scr.csr_config = CSR_CONFIG_DETPOL | CSR_CONFIG_T | CSR_CONFIG_ATRSTFLUSH | CSR_CONFIG_TSRXEN | CSR_CONFIG_CLKSTPPOL | CSR_CONFIG_PECRXE | CSR_CONFIG_MSBF | CSR_CONFIG_DPOL;\r\n\r\n    scr.inten_bm = 0xffffffff; // Enbale all the interrupts\r\n    scr.txfifo_thh = SCR_FIFO_DEPTH / 2; // set the txfifo trigger level as half full\r\n    scr.rxfifo_thh = SCR_FIFO_DEPTH / 2; // set the rxfifo trigger level as half full\r\n    scr.tx_repeat = 0x3; // iso7816\u4e2d\u89c4\u5b9a\u5bf9\u4e8e\u5b58\u5728\u4e89\u8bae\u7684\u5b57\u7b26\uff0c\u6700\u591a\u53ea\u80fd\u91cd\u53d13\u6b21\r\n    scr.rx_repeat = 0x3; // iso7816\u4e2d\u89c4\u5b9a\u5bf9\u4e8e\u5b58\u5728\u4e89\u8bae\u7684\u5b57\u7b26\uff0c\u6700\u591a\u53ea\u80fd\u91cd\u53d13\u6b21\r\n\r\n    scr.scclk_div = (APB2CLK / (2 * SCR_CLK_FRQ)) - 1; // PCLK/12, <175, && SCCLK >= 1M && =<4M\r\n    scr.baud_div = (scr.scclk_div + 1) * 372 - 1; // ETU = 372*SCCLK\r\n\r\n    scr.act_time = 1; // 1*256 clock cycle\r\n    scr.rst_time = 1; // 1*256 clock cycle\r\n    scr.atr_time = (35000 >> 8); // 400~40000   \u51b7\u590d\u4f4d\u548c\u70ed\u590d\u4f4d\u65f6,\u5728RST\u62c9\u9ad8\u540e,IO\u8981\u4f5c\u51faATR\u7684\u65f6\u95f4\u9650\u5236\r\n    scr.guard_time = 2; //=2*ETUs\t/* GT = 12etu + R * N/f   ---   Default extra\r\n        // guard time is 0 */\r\n    scr.chlimit_time = 9600; // 1024*(10+scr.guard_time); //1K Characters\r\n    scr.debounce_time = 0xfffff; // insert detect debounce time\r\n}\r\n\r\nvolatile u32 card_name = 0;\r\nvolatile u32 scr_ret = 0;\r\nuint32_t scr_test_process(pscr_struct pscr)\r\n{\r\n    uint8_t atr_temp[30];\r\n    uint8_t rsp_temp[30];\r\n    u32 i = 0;\r\n    u32 j = 0;\r\n    uint8_t atr_cmp = 0;\r\n\r\n    switch (stage) {\r\n    case sts_wait_connect:\r\n        if (scr.detected) /*if detect card, ACT the card*/\r\n        {\r\n            state_dly++;\r\n            if (state_dly >= 50) {\r\n                msleep(10);\r\n                scr_start_activation(&scr); /* Activation */\r\n                stage = sts_wait_act;\r\n                state_dly = 0;\r\n            }\r\n        } else {\r\n            state_dly = 0;\r\n        }\r\n        break;\r\n    case sts_wait_act:\r\n        if (scr.activated) {\r\n            stage = sts_wait_atr;\r\n        }\r\n        break;\r\n    case sts_wait_atr:\r\n        if (scr.atr_resp != SCR_ATR_RESP_INVALID) {\r\n            if (scr.atr_resp == SCR_ATR_RESP_OK) /*ATR response is \u6709\u6548\u7684*/\r\n            {\r\n                uint32_t i = 0;\r\n                SCR_TEST_DBG("ATR = ");\r\n                for (i = 0; i < scr.rxbuf.wptr; i++) {\r\n                    SCR_TEST_DBG("0x%02x ", *((uint8_t*)(scr.rxbuf.buffer + i)));\r\n                    atr_temp[i] = *((uint8_t*)(scr.rxbuf.buffer + i));\r\n                }\r\n                SCR_TEST_DBG(" \\n");\r\n                scr.rxbuf.rptr = scr.rxbuf.wptr;\r\n                smartcard_atr_decode(&scatr, (uint8_t*)scr.rxbuf.buffer, &pps, 1);\r\n\r\n                scr_buffer_flush(&scr.rxbuf); // clean rxbuffer\r\n                stage = sts_start_pps;\r\n\r\n                for (i = 0; i < SMART_CARD_NUM; i++) {\r\n                    u32 atr_length = ic_card_atr[i][0];\r\n                    for (j = 0; j < atr_length; j++) {\r\n                        if (atr_temp[j] != ic_card_atr[i][j + 1]) {\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (j == atr_length) {\r\n                        card_name = i;\r\n                        atr_cmp = 1;\r\n                        break;\r\n                    } else {\r\n                        atr_cmp = 0;\r\n                    }\r\n                }\r\n\r\n                if (atr_cmp) {\r\n                    printf("crad_name = %d\\n", card_name);\r\n                    printf("ATR Function PASS!!\\n");\r\n                } else {\r\n                    printf("ATR Function FAIL!!\\n");\r\n                }\r\n            } else {\r\n                stage = sts_start_deact;\r\n            }\r\n        }\r\n        break;\r\n    case sts_start_pps: /* Protocol and parameters selection */\r\n        pscr->chto_flag = 0;\r\n        scr_buffer_flush(&scr.rxbuf);\r\n\r\n        scr_write_fifo(&scr, pps.ppss);\r\n        printf("ppss:%x  \\n", pps.ppss);\r\n        scr_write_fifo(&scr, pps.pps0);\r\n        printf("pps0:%x  \\n", pps.pps0);\r\n        if (pps.pps0 & (0x1 << 4)) {\r\n            scr_write_fifo(&scr, pps.pps1);\r\n            printf("pps1:%x  \\n", pps.pps1);\r\n        }\r\n        if (pps.pps0 & (0x1 << 5)) {\r\n            scr_write_fifo(&scr, pps.pps2);\r\n            printf("pps2:%x  \\n", pps.pps2);\r\n        }\r\n        if (pps.pps0 & (0x1 << 6)) {\r\n            scr_write_fifo(&scr, pps.pps3);\r\n            printf("pps3:%x  \\n", pps.pps3);\r\n        }\r\n        scr_write_fifo(&scr, pps.pck);\r\n        printf("pck:%x  \\n", pps.pck);\r\n\r\n        stage = sts_wait_pps_resp;\r\n        break;\r\n    case sts_wait_pps_resp: // pps\u4ea4\u6362\u6210\u529f\u7684\u6700\u666e\u901a\u7684\u60c5\u51b5\u5c31\u662f:\u5361\u8bbe\u5907\u7684pps\u8bf7\u6c42\u548cic\u5361\u7684pps\u5e94\u7b54\u7684\u5185\u5bb9\u5b8c\u5168\u4e00\u6837\r\n        if (pscr->chto_flag) // Wait Data Timeout/*time is too long, time is\r\n        // out*/\r\n        {\r\n            if (scr_buffer_is_empty(&scr.rxbuf)) // RX Buffer, No Response\r\n            {\r\n                SCR_TEST_INFO("No PPS Response!!\\n");\r\n                stage = sts_warm_reset;\r\n            } else {\r\n                uint8_t data = scr_dump_buffer(&scr.rxbuf); // read ppss\r\n                printf("ppss:%x  \\n", data);\r\n                if (data != pps.ppss) // check ppss\r\n                {\r\n                    SCR_TEST_INFO("PPS Resp Start Error: 0x%x !!\\n", data);\r\n                    break;\r\n                }\r\n                if (scr_buffer_is_empty(&scr.rxbuf)) // no pps0\r\n                {\r\n                    SCR_TEST_INFO("PPS Resp Too Short 1\\n");\r\n                    break;\r\n                }\r\n                data = scr_dump_buffer(&scr.rxbuf); // read pps0\r\n                printf("pps0:%x  \\n", data);\r\n                if (data != pps.pps0) // check pps0\r\n                {\r\n                    SCR_TEST_INFO("PPS Resp PPS0 Error: 0x%x vs 0x%x !!\\n", pps.pps0,\r\n                        data);\r\n                    break;\r\n                }\r\n                if (pps.pps0 & (0x1 << 4)) //\u6839\u636epps0\u7684\u503c,\u6709pps1\r\n                {\r\n                    if (scr_buffer_is_empty(&scr.rxbuf)) //\u6536\u4e0d\u5230pps1\r\n                    {\r\n                        SCR_TEST_INFO("PPS Resp Too Short 2\\n");\r\n                        break;\r\n                    }\r\n                    data = scr_dump_buffer(&scr.rxbuf); //\u8bfb\u53d6pps1\r\n                    printf("pps1:%x  \\n", data);\r\n                    if (data != pps.pps1) //\u68c0\u6d4bpps1\r\n                    {\r\n                        SCR_TEST_INFO("PPS Resp PPS1 Error: 0x%x vs 0x%x !!\\n", pps.pps1,\r\n                            data);\r\n                        break;\r\n                    }\r\n                }\r\n                if (pps.pps0 & (0x1 << 5)) //\u6839\u636epps0\u7684\u503c,\u6709pps2\r\n                {\r\n                    if (scr_buffer_is_empty(&scr.rxbuf)) //\u6536\u4e0d\u5230pps2\r\n                    {\r\n                        SCR_TEST_INFO("PPS Resp Too Short 3\\n");\r\n                        break;\r\n                    }\r\n                    data = scr_dump_buffer(&scr.rxbuf); //\u8bfb\u53d6pps2\r\n                    printf("pps2:%x  \\n", data);\r\n                    if (data != pps.pps2) //\u68c0\u6d4bpps2\r\n                    {\r\n                        SCR_TEST_INFO("PPS Resp PPS2 Error: 0x%x vs 0x%x !!\\n", pps.pps2,\r\n                            data);\r\n                        break;\r\n                    }\r\n                }\r\n                if (pps.pps0 & (0x1 << 6)) //\u6839\u636epps0\u7684\u503c,\u6709pps3\r\n                {\r\n                    if (scr_buffer_is_empty(&scr.rxbuf)) //\u6536\u4e0d\u5230pps3\r\n                    {\r\n                        SCR_TEST_INFO("PPS Resp Too Short 4\\n");\r\n                        break;\r\n                    }\r\n                    data = scr_dump_buffer(&scr.rxbuf); //\u8bfb\u53d6pps3\r\n                    printf("pps3:%x  \\n", data);\r\n                    if (data != pps.pps3) //\u68c0\u6d4bpps3\r\n                    {\r\n                        SCR_TEST_INFO("PPS Resp PPS3 Error: 0x%x vs 0x%x !!\\n", pps.pps3,\r\n                            data);\r\n                        break;\r\n                    }\r\n                }\r\n                if (scr_buffer_is_empty(&scr.rxbuf)) //\u6536\u4e0d\u5230pck\r\n                {\r\n                    SCR_TEST_INFO("PPS Resp Too Short 5\\n");\r\n                    break;\r\n                }\r\n                data = scr_dump_buffer(&scr.rxbuf); //\u8bfb\u53d6pck\r\n                printf("pck:%x  \\n", data);\r\n                if (data != pps.pck) //\u68c0\u6d4bpck\r\n                {\r\n                    SCR_TEST_INFO("PPS Resp PCK Error: 0x%x vs 0x%x !!\\n", pps.pck, data);\r\n                    break;\r\n                }\r\n\r\n                scr_buffer_flush(&scr.rxbuf);\r\n                stage = sts_send_cmd;\r\n\r\n                SCR_TEST_INFO(\r\n                    "PPS Response OK!!\\n"); //\u5982\u679c\u4e0a\u8ff0if\u4e2d\u90fd\u6ca1\u6709break\u51fa\u6765,\u5219\u8868\u793apps\u4ea4\u6362\u6210\u529f\r\n\r\n                scr.baud_div = (scr.scclk_div + 1) * (scatr.F) / (scatr.D) - 1;\r\n                scr_set_baud_divisor(&scr, pscr->baud_div);\r\n            }\r\n        }\r\n        break;\r\n\r\n    case sts_warm_reset:\r\n        scr.atr_resp = SCR_ATR_RESP_INVALID;\r\n        scr_start_warmreset(&scr);\r\n        stage = sts_wait_atr_again;\r\n        break;\r\n\r\n    case sts_wait_atr_again:\r\n        if (scr.atr_resp != SCR_ATR_RESP_INVALID) {\r\n            if (scr.atr_resp == SCR_ATR_RESP_OK) /*ATR response is \u6709\u6548\u7684*/\r\n            {\r\n                uint32_t i = 0;\r\n                SCR_TEST_DBG("ATR : ");\r\n                for (i = 0; i < scr.rxbuf.wptr; i++) {\r\n                    SCR_TEST_DBG("0x%02x ", *((uint8_t*)(scr.rxbuf.buffer + i)));\r\n                    atr_temp[i] = *((uint8_t*)(scr.rxbuf.buffer + i));\r\n                }\r\n                SCR_TEST_DBG(" \\n");\r\n                scr.rxbuf.rptr = scr.rxbuf.wptr;\r\n                smartcard_atr_decode(&scatr, (uint8_t*)scr.rxbuf.buffer, &pps, 1);\r\n\r\n                for (i = 0; i < SMART_CARD_NUM; i++) {\r\n                    u32 atr_length = ic_card_atr[i][0];\r\n                    for (j = 0; j < atr_length; j++) {\r\n                        if (atr_temp[j] != ic_card_atr[i][j + 1]) {\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (j == atr_length) {\r\n                        card_name = i;\r\n                        atr_cmp = 1;\r\n                        break;\r\n                    } else {\r\n                        atr_cmp = 0;\r\n                    }\r\n                }\r\n\r\n                if (atr_cmp) {\r\n                    printf("crad_name = %d\\n", card_name);\r\n                    printf("ATR Function PASS!!\\n");\r\n                } else {\r\n                    printf("ATR Function FAIL!!\\n");\r\n                }\r\n\r\n                scr.baud_div = (scr.scclk_div + 1) * (scatr.F) / (scatr.D) - 1;\r\n                scr_set_baud_divisor(&scr, pscr->baud_div);\r\n\r\n                scr_buffer_flush(&scr.rxbuf); // clean rxbuffer\r\n                stage = sts_send_cmd;\r\n            } else {\r\n                stage = sts_start_deact;\r\n            }\r\n        }\r\n        break;\r\n\r\n    case sts_send_cmd: //\u8fd9\u91cc\u5e94\u8be5\u53ef\u4ee5\u52a0\u5165\u6211\u4eec\u60f3\u8981\u7684\u6c9f\u901a\u547d\u4ee4\r\n    {\r\n        uint8_t cmp_rlt = 0;\r\n        if (ic_card_send_cmd[card_name][0]) {\r\n            for (i = 0; i < ic_card_send_cmd[card_name][0]; i++) {\r\n                uint8_t send = ic_card_send_cmd[card_name][i + 1];\r\n                scr_write_fifo(&scr, send);\r\n            }\r\n            msleep(1000);\r\n            scr_rx_fifo_read(rsp_temp);\r\n\r\n            for (i = 0; i < ic_card_rev_data[card_name][0]; i++) {\r\n                if (rsp_temp[i] != ic_card_rev_data[card_name][i + 1]) {\r\n                    cmp_rlt = 1;\r\n                }\r\n            }\r\n            if (cmp_rlt) {\r\n                printf("Communication Command Error: ");\r\n                for (i = 0; i < ic_card_rev_data[card_name][0]; i++)\r\n                    printf("0x%02x  ", rsp_temp[i]);\r\n                printf("\\n");\r\n                scr_ret++;\r\n            } else {\r\n                printf("Communication Command Respone PASS!!\\n");\r\n            }\r\n        } else {\r\n            printf("No communication command, No command test!!\\n");\r\n            stage = sts_idle;\r\n        }\r\n        msleep(1000);\r\n    } break;\r\n    case sts_start_deact:\r\n        stage = sts_wait_deact;\r\n        scr_start_deactivation(&scr); /* Deactivation */\r\n        msleep(10);\r\n        break;\r\n    case sts_wait_deact:\r\n        if (!scr.activated) {\r\n            stage = sts_wait_disconnect;\r\n            scr_module_rst(SCR_NO);\r\n            scr_params_init();\r\n            smartcard_params_init(&scatr); /*set smart card protocol, v,i,frequency*/\r\n            scr_init(&scr);\r\n        }\r\n        break;\r\n    case sts_wait_disconnect:\r\n        if (!scr.detected)\r\n            stage = sts_wait_connect;\r\n\r\n        break;\r\n\r\n    case sts_idle:\r\n        msleep(50);\r\n        if (sts_idle == stage)\r\n            stage = sts_idle;\r\n        break;\r\n    default:\r\n        stage = sts_idle;\r\n        break;\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\nvoid scr_data_transfer_test(void)\r\n{\r\n    scr_params_init();\r\n    scr_init(&scr);\r\n    reg_scr0_irq_handler();\r\n    scr_global_interrupt_enable(&scr);\r\n    while (1)\r\n        scr_test_process(&scr);\r\n}\r\n\r\n/* s32 scr_test(void) */\r\nint scr_test1(int argc, char** argv)\r\n{\r\n    scr_params_init();\r\n    /*register default check and read write check*/\r\n    scr_system_setup(SCR_NO);\r\n\r\n    if (scr_reg_test() != 1)\r\n        return -1;\r\n\r\n    /*SCR Control and smart card data transfer test*/\r\n    scr_system_setup(SCR_NO);\r\n\r\n    scr_data_transfer_test();\r\n\r\n    return 0;\r\n}\r\nFINSH_FUNCTION_EXPORT_CMD(scr_test1, hal_smartcard, smartcard);\n'})})]})}function p(r={}){const{wrapper:n}={...(0,t.a)(),...r.components};return n?(0,e.jsx)(n,{...r,children:(0,e.jsx)(f,{...r})}):f(r)}},11151:(r,n,s)=>{s.d(n,{Z:()=>_,a:()=>c});var e=s(67294);const t={},a=e.createContext(t);function c(r){const n=e.useContext(a);return e.useMemo((function(){return"function"==typeof r?r(n):{...n,...r}}),[n,r])}function _(r){let n;return n=r.disableParentContext?"function"==typeof r.components?r.components(t):r.components||t:c(r.components),e.createElement(a.Provider,{value:n},r.children)}}}]);