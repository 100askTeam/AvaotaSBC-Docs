"use strict";(self.webpackChunkavaota_docs=self.webpackChunkavaota_docs||[]).push([[1047],{41792:(n,r,e)=>{e.r(r),e.d(r,{assets:()=>c,contentTitle:()=>d,default:()=>C,frontMatter:()=>t,metadata:()=>s,toc:()=>l});var _=e(85893),i=e(11151);const t={},d="IR TX - \u7ea2\u5916\u53d1\u5c04",s={id:"linux-manual/sdk-develop/bsp-driver/ir-tx",title:"IR TX - \u7ea2\u5916\u53d1\u5c04",description:"IR-TX\u662f\u4e00\u79cd\u7ea2\u5916\u53d1\u9001\u6a21\u5757\uff0c\u5176\u4e3b\u8981\u529f\u80fd\u662f\u8f93\u51fa\u7ea2\u5916\u6ce2\u5f62\u3002\u901a\u5e38\u60c5\u51b5\u4e0b\uff0c\u5b83\u91c7\u752838KHz\u7684\u8f7d\u6ce2\u9891\u7387\u3002\u8be5\u6a21\u5757\u80fd\u591f\u5c06\u6570\u636e\u8f6c\u6362\u6210\u4e00\u7cfb\u5217\u9ad8\u4f4e\u7535\u5e73\u5e8f\u5217\uff0c\u4ee5\u4fbf\u53d1\u9001\u7ea2\u5916\u4fe1\u53f7\u3002\u5728\u53d1\u9001\u8fc7\u7a0b\u4e2d\uff0c\u6bcf\u4e2a\u6709\u6548\u8109\u51b2\u7684\u6570\u636e\u90fd\u4ee5\u5b57\u8282\u4e3a\u5355\u4f4d\u88ab\u7f13\u5b58\u5230TX FIFO\u4e2d\u3002\u5728\u6bcf\u4e2a\u5b57\u8282\u4e2d\uff0c\u6700\u9ad8\u4f4d\uff08bit7\uff09\u8868\u793a\u8981\u53d1\u9001\u6ce2\u5f62\u7684\u6781\u6027\uff0c\u5176\u4e2d1\u8868\u793a\u9ad8\u7535\u5e73\uff0c0\u8868\u793a\u4f4e\u7535\u5e73\u3002\u800c\u4f4e7\u4f4d\uff08bit[61]\u6765\u8bbe\u7f6e\u3002",source:"@site/docs/linux-manual/sdk-develop/bsp-driver/ir-tx.md",sourceDirName:"linux-manual/sdk-develop/bsp-driver",slug:"/linux-manual/sdk-develop/bsp-driver/ir-tx",permalink:"/linux-manual/sdk-develop/bsp-driver/ir-tx",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"linuxManualSidebar",previous:{title:"IR RX - \u7ea2\u5916\u63a5\u6536",permalink:"/linux-manual/sdk-develop/bsp-driver/ir-rx"},next:{title:"LEDC - \u53d1\u5149\u4e8c\u6781\u7ba1\u63a7\u5236\u5668",permalink:"/linux-manual/sdk-develop/bsp-driver/ledc"}},c={},l=[{value:"\u6a21\u5757\u914d\u7f6e",id:"\u6a21\u5757\u914d\u7f6e",level:2},{value:"\u9a71\u52a8\u914d\u7f6e",id:"\u9a71\u52a8\u914d\u7f6e",level:3},{value:"\u8bbe\u5907\u6811\u914d\u7f6e",id:"\u8bbe\u5907\u6811\u914d\u7f6e",level:3},{value:"\u6a21\u5757\u63a5\u53e3",id:"\u6a21\u5757\u63a5\u53e3",level:2},{value:"<code>evdev_open()</code>",id:"evdev_open",level:3},{value:"<code>evdev_read()</code>",id:"evdev_read",level:3},{value:"<code>evdev_write()</code>",id:"evdev_write",level:3},{value:"<code>evdev_ioctl()</code>",id:"evdev_ioctl",level:3},{value:"\u6a21\u5757 DEMO",id:"\u6a21\u5757-demo",level:2}];function o(n){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.a)(),...n.components};return(0,_.jsxs)(_.Fragment,{children:[(0,_.jsx)(r.h1,{id:"ir-tx---\u7ea2\u5916\u53d1\u5c04",children:"IR TX - \u7ea2\u5916\u53d1\u5c04"}),"\n",(0,_.jsx)(r.p,{children:"IR-TX\u662f\u4e00\u79cd\u7ea2\u5916\u53d1\u9001\u6a21\u5757\uff0c\u5176\u4e3b\u8981\u529f\u80fd\u662f\u8f93\u51fa\u7ea2\u5916\u6ce2\u5f62\u3002\u901a\u5e38\u60c5\u51b5\u4e0b\uff0c\u5b83\u91c7\u752838KHz\u7684\u8f7d\u6ce2\u9891\u7387\u3002\u8be5\u6a21\u5757\u80fd\u591f\u5c06\u6570\u636e\u8f6c\u6362\u6210\u4e00\u7cfb\u5217\u9ad8\u4f4e\u7535\u5e73\u5e8f\u5217\uff0c\u4ee5\u4fbf\u53d1\u9001\u7ea2\u5916\u4fe1\u53f7\u3002\u5728\u53d1\u9001\u8fc7\u7a0b\u4e2d\uff0c\u6bcf\u4e2a\u6709\u6548\u8109\u51b2\u7684\u6570\u636e\u90fd\u4ee5\u5b57\u8282\u4e3a\u5355\u4f4d\u88ab\u7f13\u5b58\u5230TX FIFO\u4e2d\u3002\u5728\u6bcf\u4e2a\u5b57\u8282\u4e2d\uff0c\u6700\u9ad8\u4f4d\uff08bit7\uff09\u8868\u793a\u8981\u53d1\u9001\u6ce2\u5f62\u7684\u6781\u6027\uff0c\u5176\u4e2d1\u8868\u793a\u9ad8\u7535\u5e73\uff0c0\u8868\u793a\u4f4e\u7535\u5e73\u3002\u800c\u4f4e7\u4f4d\uff08bit[6:0]\uff09\u8868\u793a\u8be5\u6ce2\u5f62\u7684\u957f\u5ea6\uff0c\u5176\u5355\u4f4d\u662f\u53c2\u8003\u65f6\u949f\u5468\u671f\uff08Ts=Fclk/RCS\uff09\u3002\u8fd9\u91cc\uff0cFclk\u8868\u793aIR-TX\u6a21\u5757\u7684\u65f6\u949f\u6e90\u9891\u7387\uff0c\u800cRCS\u5219\u662f\u53c2\u8003\u65f6\u949f\u7684\u5206\u9891\u7cfb\u6570\uff0c\u53ef\u7531TCR\u5bc4\u5b58\u5668\uff08\u5730\u5740\u4e3a0x08\uff09\u7684bit[3:1]\u6765\u8bbe\u7f6e\u3002"}),"\n",(0,_.jsx)(r.p,{children:(0,_.jsx)(r.img,{alt:"image-20240401233043036",src:e(96435).Z+"",width:"858",height:"486"})}),"\n",(0,_.jsx)(r.h2,{id:"\u6a21\u5757\u914d\u7f6e",children:"\u6a21\u5757\u914d\u7f6e"}),"\n",(0,_.jsx)(r.h3,{id:"\u9a71\u52a8\u914d\u7f6e",children:"\u9a71\u52a8\u914d\u7f6e"}),"\n",(0,_.jsx)(r.pre,{children:(0,_.jsx)(r.code,{children:"IR-TX Drivers ->\r\n\t<*> IR-TX Support for Allwinner SoCs\n"})}),"\n",(0,_.jsx)(r.p,{children:(0,_.jsx)(r.img,{alt:"image-20240401233113163",src:e(689).Z+"",width:"1084",height:"260"})}),"\n",(0,_.jsx)(r.h3,{id:"\u8bbe\u5907\u6811\u914d\u7f6e",children:"\u8bbe\u5907\u6811\u914d\u7f6e"}),"\n",(0,_.jsx)(r.p,{children:"\u516c\u5171\u914d\u7f6e"}),"\n",(0,_.jsx)(r.pre,{children:(0,_.jsx)(r.code,{className:"language-c",children:'irtx: ir@2003000 {\r\n    compatible = "allwinner,irtx";\r\n    reg = <0x0 0x02003000 0x0 0x400>;\r\n    interrupts = <GIC_SPI 26 IRQ_TYPE_LEVEL_HIGH>;\r\n    clocks = <&ccu CLK_BUS_IRTX>, <&dcxo24M>, <&ccu CLK_IRTX>;\r\n    clock-names = "bus", "pclk", "mclk";\r\n    resets = <&ccu RST_BUS_IRTX>;\r\n    status = "disabled";\r\n};\n'})}),"\n",(0,_.jsx)(r.p,{children:"\u5f15\u811a\u914d\u7f6e"}),"\n",(0,_.jsx)(r.pre,{children:(0,_.jsx)(r.code,{className:"language-c",children:'&pio {\r\n    irtx_pins_default: irtx@0 {\r\n        pins = "PH18";\r\n        function = "cir";\r\n    };\r\n\r\n    irtx_pins_sleep: irtx@1 {\r\n        pins = "PH18";\r\n        function = "gpio_in";\r\n    };\r\n};\n'})}),"\n",(0,_.jsx)(r.p,{children:"\u6a21\u5757\u914d\u7f6e"}),"\n",(0,_.jsx)(r.pre,{children:(0,_.jsx)(r.code,{className:"language-c",children:'&irtx {\r\n    pinctrl-names = "default", "sleep";\r\n    pinctrl-0 = <&irtx_pins_default>;\r\n    pinctrl-1 = <&irtx_pins_sleep>;\r\n    status = "okay";\r\n};\n'})}),"\n",(0,_.jsx)(r.h2,{id:"\u6a21\u5757\u63a5\u53e3",children:"\u6a21\u5757\u63a5\u53e3"}),"\n",(0,_.jsx)(r.p,{children:"IR-TX\u6a21\u5757\u91c7\u7528\u901a\u7528\u7684RC\u6846\u67b6\u8fdb\u884c\u8bfb\u5199\uff0c\u6240\u4ee5\u53ef\u4ee5\u4f7f\u7528\u901a\u7528\u7684\u63a5\u53e3\u3002"}),"\n",(0,_.jsx)(r.h3,{id:"evdev_open",children:(0,_.jsx)(r.code,{children:"evdev_open()"})}),"\n",(0,_.jsxs)(r.ul,{children:["\n",(0,_.jsxs)(r.li,{children:["\u51fd\u6570\u539f\u578b\uff1a",(0,_.jsx)(r.code,{children:"static int evdev_open(struct inode *inode, struct file *file)"}),"\u3002"]}),"\n",(0,_.jsxs)(r.li,{children:["\u529f\u80fd\u63cf\u8ff0\uff1a\u7a0b\u5e8f\uff08C\u8bed\u8a00\u7b49\uff09\u4f7f\u7528 ",(0,_.jsx)(r.code,{children:"open(file)"})," \u65f6\u8c03\u7528\u7684\u51fd\u6570\u3002\u6253\u5f00\u4e00\u4e2aIR-TX\u6a21\u5757\u8bbe\u5907\u3002"]}),"\n",(0,_.jsxs)(r.li,{children:["\u53c2\u6570\u8bf4\u660e\uff1a",(0,_.jsx)(r.code,{children:"inode"}),"\uff1ainode\u8282\u70b9\uff1b",(0,_.jsx)(r.code,{children:"file"}),"\uff1afile\u7ed3\u6784\u4f53\u3002"]}),"\n",(0,_.jsx)(r.li,{children:"\u8fd4\u56de\u503c\uff1a\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002"}),"\n"]}),"\n",(0,_.jsx)(r.h3,{id:"evdev_read",children:(0,_.jsx)(r.code,{children:"evdev_read()"})}),"\n",(0,_.jsxs)(r.ul,{children:["\n",(0,_.jsxs)(r.li,{children:["\u51fd\u6570\u539f\u578b\uff1a",(0,_.jsx)(r.code,{children:"static ssize_t evdev_read(struct file *file, char __user *buffer, size_t count, loff_t *ppos)"}),"\u3002"]}),"\n",(0,_.jsxs)(r.li,{children:["\u529f\u80fd\u63cf\u8ff0\uff1a\u7a0b\u5e8f\uff08C\u8bed\u8a00\u7b49\uff09\u8c03\u7528 ",(0,_.jsx)(r.code,{children:"read()"})," \u65f6\u8c03\u7528\u7684\u51fd\u6570\u3002\u8bfb\u53d6IR-TX\u6a21\u5757\u4e0a\u62a5\u4e8b\u4ef6\u6570\u636e\u3002"]}),"\n",(0,_.jsxs)(r.li,{children:["\u53c2\u6570\u8bf4\u660e\uff1a",(0,_.jsx)(r.code,{children:"file"}),"\uff1afile\u7ed3\u6784\u4f53\uff1b",(0,_.jsx)(r.code,{children:"buffer"}),"\uff1a\u5199\u6570\u636e\u7f13\u51b2\u533a\uff1b",(0,_.jsx)(r.code,{children:"count"}),"\uff1a\u8981\u8bfb\u53d6\u7684\u5b57\u8282\u6570\uff1b",(0,_.jsx)(r.code,{children:"ppos"}),"\uff1a\u6587\u4ef6\u504f\u79fb\u91cf\u3002"]}),"\n",(0,_.jsx)(r.li,{children:"\u8fd4\u56de\u503c\uff1a\u6210\u529f\u8fd4\u56de\u8bfb\u53d6\u7684\u5b57\u8282\u6570\uff0c\u5931\u8d25\u8fd4\u56de\u8d1f\u6570\u3002"}),"\n"]}),"\n",(0,_.jsx)(r.h3,{id:"evdev_write",children:(0,_.jsx)(r.code,{children:"evdev_write()"})}),"\n",(0,_.jsxs)(r.ul,{children:["\n",(0,_.jsxs)(r.li,{children:["\u51fd\u6570\u539f\u578b\uff1a",(0,_.jsx)(r.code,{children:"static ssize_t evdev_write(struct file *file, const char __user *buffer, size_t count, loff_t *ppos)"}),"\u3002"]}),"\n",(0,_.jsxs)(r.li,{children:["\u529f\u80fd\u63cf\u8ff0\uff1a\u7a0b\u5e8f\uff08C\u8bed\u8a00\u7b49\uff09\u8c03\u7528 ",(0,_.jsx)(r.code,{children:"write()"})," \u65f6\u8c03\u7528\u7684\u51fd\u6570\u3002\u5411IR-TX\u6a21\u5757\u5199\u5165\u4e0a\u62a5\u4e8b\u4ef6\u3002"]}),"\n",(0,_.jsxs)(r.li,{children:["\u53c2\u6570\u8bf4\u660e\uff1a",(0,_.jsx)(r.code,{children:"file"}),"\uff1afile\u7ed3\u6784\u4f53\uff1b",(0,_.jsx)(r.code,{children:"buffer"}),"\uff1a\u8bfb\u6570\u636e\u7f13\u51b2\u533a\uff1b",(0,_.jsx)(r.code,{children:"count"}),"\uff1a\u8981\u5199\u5165\u7684\u5b57\u8282\u6570\uff1b",(0,_.jsx)(r.code,{children:"ppos"}),"\uff1a\u6587\u4ef6\u504f\u79fb\u91cf\u3002"]}),"\n",(0,_.jsx)(r.li,{children:"\u8fd4\u56de\u503c\uff1a\u6210\u529f\u8fd4\u56de0\uff0c\u5931\u8d25\u8fd4\u56de\u8d1f\u6570\u3002"}),"\n"]}),"\n",(0,_.jsx)(r.h3,{id:"evdev_ioctl",children:(0,_.jsx)(r.code,{children:"evdev_ioctl()"})}),"\n",(0,_.jsxs)(r.ul,{children:["\n",(0,_.jsxs)(r.li,{children:["\u51fd\u6570\u539f\u578b\uff1a",(0,_.jsx)(r.code,{children:"static long evdev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)"}),"\u3002"]}),"\n",(0,_.jsxs)(r.li,{children:["\u529f\u80fd\u63cf\u8ff0\uff1a\u7a0b\u5e8f\uff08C\u8bed\u8a00\u7b49\uff09\u8c03\u7528 ",(0,_.jsx)(r.code,{children:"ioctl()"})," \u65f6\u8c03\u7528\u7684\u51fd\u6570\u3002\u7ba1\u7406\u76f8\u5173\u7684IR-TX\u6a21\u5757\u529f\u80fd\u3002"]}),"\n",(0,_.jsxs)(r.li,{children:["\u53c2\u6570\u8bf4\u660e\uff1a",(0,_.jsx)(r.code,{children:"file"}),"\uff1afile\u7ed3\u6784\u4f53\uff1b",(0,_.jsx)(r.code,{children:"cmd"}),"\uff1a\u6307\u4ee4\uff1b",(0,_.jsx)(r.code,{children:"arg"}),"\uff1a\u5176\u4ed6\u53c2\u6570\u3002"]}),"\n",(0,_.jsx)(r.li,{children:"\u8fd4\u56de\u503c\uff1a\u6210\u529f\u8fd4\u56de0\uff0c\u5931\u8d25\u8fd4\u56de\u8d1f\u6570\u3002"}),"\n"]}),"\n",(0,_.jsx)(r.h2,{id:"\u6a21\u5757-demo",children:"\u6a21\u5757 DEMO"}),"\n",(0,_.jsxs)(r.p,{children:["\u8be5 DEMO \u53ef\u4ee5\u7528\u6765\u8c03\u7528TX\u6a21\u5757\u53d1\u9001\u6570\u636e\u4fe1\u53f7.\r\n\u6d4b\u8bd5\u547d\u4ee4\uff1a",(0,_.jsx)(r.code,{children:"tx 0x04 3800"}),"\r\n\u6ce8\uff1aDEMO \u91c7\u7528NEC\u534f\u8bae\u8fdb\u884c\u7f16\u7801\uff0c\u8bbe\u7f6e\u8f7d\u6ce2\u5360\u7a7a\u6bd4\u4e3a33%\uff0c\u8bbe\u7f6e\u8f7d\u6ce2\u9891\u7387\u4e3a38KHz\u3002"]}),"\n",(0,_.jsx)(r.pre,{children:(0,_.jsx)(r.code,{className:"language-c",children:'#include <linux/types.h>\r\n#include <linux/ioctl.h>\r\n#include <sys/types.h>\r\n#include <sys/stat.h>\r\n#include <sys/ioctl.h>\r\n#include <fcntl.h>\r\n#include <stdio.h>\r\n#include <stdint.h>\r\n#include <stdlib.h>\r\n#include <poll.h>\r\n#include <signal.h>\r\n#include <sys/types.h>\r\n#include <linux/types.h>\r\n#include <pthread.h>\r\n#include <unistd.h>\r\n#include <string.h>\r\n#include <errno.h>\r\n#include <unistd.h>\r\n\r\n#define PULSE_BIT       0x01000000\r\n#define PULSE_MASK      0x00FFFFFF\r\n\r\n#define LIRC_MODE2_SPACE     0x00000000\r\n#define LIRC_MODE2_PULSE     0x01000000\r\n#define LIRC_MODE2_FREQUENCY 0x02000000\r\n#define LIRC_MODE2_TIMEOUT   0x03000000\r\n\r\n#define LIRC_VALUE_MASK      0x00FFFFFF\r\n#define LIRC_MODE2_MASK      0xFF000000\r\n\r\n#define LIRC_SPACE(val) (((val)&LIRC_VALUE_MASK) | LIRC_MODE2_SPACE)\r\n#define LIRC_PULSE(val) (((val)&LIRC_VALUE_MASK) | LIRC_MODE2_PULSE)\r\n#define LIRC_FREQUENCY(val) (((val)&LIRC_VALUE_MASK) | LIRC_MODE2_FREQUENCY)\r\n#define LIRC_TIMEOUT(val) (((val)&LIRC_VALUE_MASK) | LIRC_MODE2_TIMEOUT)\r\n\r\n#define LIRC_VALUE(val) ((val)&LIRC_VALUE_MASK)\r\n#define LIRC_MODE2(val) ((val)&LIRC_MODE2_MASK)\r\n\r\n#define LIRC_IS_SPACE(val) (LIRC_MODE2(val) == LIRC_MODE2_SPACE)\r\n#define LIRC_IS_PULSE(val) (LIRC_MODE2(val) == LIRC_MODE2_PULSE)\r\n#define LIRC_IS_FREQUENCY(val) (LIRC_MODE2(val) == LIRC_MODE2_FREQUENCY)\r\n#define LIRC_IS_TIMEOUT(val) (LIRC_MODE2(val) == LIRC_MODE2_TIMEOUT)\r\n\r\n/* used heavily by lirc userspace */\r\n#define lirc_t int\r\n\r\n/*** lirc compatible hardware features ***/\r\n\r\n#define LIRC_MODE2SEND(x) (x)\r\n#define LIRC_SEND2MODE(x) (x)\r\n#define LIRC_MODE2REC(x) ((x) << 16)\r\n#define LIRC_REC2MODE(x) ((x) >> 16)\r\n\r\n#define LIRC_MODE_RAW                  0x00000001\r\n#define LIRC_MODE_PULSE                0x00000002\r\n#define LIRC_MODE_MODE2                0x00000004\r\n#define LIRC_MODE_SCANCODE             0x00000008\r\n#define LIRC_MODE_LIRCCODE             0x00000010\r\n\r\n\r\n#define LIRC_CAN_SEND_RAW              LIRC_MODE2SEND(LIRC_MODE_RAW)\r\n#define LIRC_CAN_SEND_PULSE            LIRC_MODE2SEND(LIRC_MODE_PULSE)\r\n#define LIRC_CAN_SEND_MODE2            LIRC_MODE2SEND(LIRC_MODE_MODE2)\r\n#define LIRC_CAN_SEND_LIRCCODE         LIRC_MODE2SEND(LIRC_MODE_LIRCCODE)\r\n\r\n#define LIRC_CAN_SEND_MASK             0x0000003f\r\n\r\n#define LIRC_CAN_SET_SEND_CARRIER      0x00000100\r\n#define LIRC_CAN_SET_SEND_DUTY_CYCLE   0x00000200\r\n#define LIRC_CAN_SET_TRANSMITTER_MASK  0x00000400\r\n\r\n#define LIRC_CAN_REC_RAW               LIRC_MODE2REC(LIRC_MODE_RAW)\r\n#define LIRC_CAN_REC_PULSE             LIRC_MODE2REC(LIRC_MODE_PULSE)\r\n#define LIRC_CAN_REC_MODE2             LIRC_MODE2REC(LIRC_MODE_MODE2)\r\n#define LIRC_CAN_REC_SCANCODE          LIRC_MODE2REC(LIRC_MODE_SCANCODE)\r\n#define LIRC_CAN_REC_LIRCCODE          LIRC_MODE2REC(LIRC_MODE_LIRCCODE)\r\n\r\n#define LIRC_CAN_REC_MASK              LIRC_MODE2REC(LIRC_CAN_SEND_MASK)\r\n\r\n#define LIRC_CAN_SET_REC_CARRIER       (LIRC_CAN_SET_SEND_CARRIER << 16)\r\n#define LIRC_CAN_SET_REC_DUTY_CYCLE    (LIRC_CAN_SET_SEND_DUTY_CYCLE << 16)\r\n\r\n#define LIRC_CAN_SET_REC_DUTY_CYCLE_RANGE 0x40000000\r\n#define LIRC_CAN_SET_REC_CARRIER_RANGE    0x80000000\r\n#define LIRC_CAN_GET_REC_RESOLUTION       0x20000000\r\n#define LIRC_CAN_SET_REC_TIMEOUT          0x10000000\r\n#define LIRC_CAN_SET_REC_FILTER           0x08000000\r\n\r\n#define LIRC_CAN_MEASURE_CARRIER          0x02000000\r\n#define LIRC_CAN_USE_WIDEBAND_RECEIVER    0x04000000\r\n\r\n#define LIRC_CAN_SEND(x) ((x)&LIRC_CAN_SEND_MASK)\r\n#define LIRC_CAN_REC(x) ((x)&LIRC_CAN_REC_MASK)\r\n\r\n#define LIRC_CAN_NOTIFY_DECODE            0x01000000\r\n\r\n/*** IOCTL commands for lirc driver ***/\r\n\r\n#define LIRC_GET_FEATURES              _IOR(\'i\', 0x00000000, __u32)\r\n\r\n#define LIRC_GET_SEND_MODE             _IOR(\'i\', 0x00000001, __u32)\r\n#define LIRC_GET_REC_MODE              _IOR(\'i\', 0x00000002, __u32)\r\n#define LIRC_GET_REC_RESOLUTION        _IOR(\'i\', 0x00000007, __u32)\r\n\r\n#define LIRC_GET_MIN_TIMEOUT           _IOR(\'i\', 0x00000008, __u32)\r\n#define LIRC_GET_MAX_TIMEOUT           _IOR(\'i\', 0x00000009, __u32)\r\n\r\n/* code length in bits, currently only for LIRC_MODE_LIRCCODE */\r\n#define LIRC_GET_LENGTH                _IOR(\'i\', 0x0000000f, __u32)\r\n\r\n#define LIRC_SET_SEND_MODE             _IOW(\'i\', 0x00000011, __u32)\r\n#define LIRC_SET_REC_MODE              _IOW(\'i\', 0x00000012, __u32)\r\n/* Note: these can reset the according pulse_width */\r\n#define LIRC_SET_SEND_CARRIER          _IOW(\'i\', 0x00000013, __u32)\r\n#define LIRC_SET_REC_CARRIER           _IOW(\'i\', 0x00000014, __u32)\r\n#define LIRC_SET_SEND_DUTY_CYCLE       _IOW(\'i\', 0x00000015, __u32)\r\n#define LIRC_SET_TRANSMITTER_MASK      _IOW(\'i\', 0x00000017, __u32)\r\n\r\n/*\r\n * when a timeout != 0 is set the driver will send a\r\n * LIRC_MODE2_TIMEOUT data packet, otherwise LIRC_MODE2_TIMEOUT is\r\n * never sent, timeout is disabled by default\r\n */\r\n#define LIRC_SET_REC_TIMEOUT           _IOW(\'i\', 0x00000018, __u32)\r\n\r\n/* 1 enables, 0 disables timeout reports in MODE2 */\r\n#define LIRC_SET_REC_TIMEOUT_REPORTS   _IOW(\'i\', 0x00000019, __u32)\r\n\r\n/*\r\n * if enabled from the next key press on the driver will send\r\n * LIRC_MODE2_FREQUENCY packets\r\n */\r\n#define LIRC_SET_MEASURE_CARRIER_MODE    _IOW(\'i\', 0x0000001d, __u32)\r\n\r\n/*\r\n * to set a range use LIRC_SET_REC_CARRIER_RANGE with the\r\n * lower bound first and later LIRC_SET_REC_CARRIER with the upper bound\r\n */\r\n#define LIRC_SET_REC_CARRIER_RANGE     _IOW(\'i\', 0x0000001f, __u32)\r\n\r\n#define LIRC_SET_WIDEBAND_RECEIVER     _IOW(\'i\', 0x00000023, __u32)\r\n\r\n/*\r\n * Return the recording timeout, which is either set by\r\n * the ioctl LIRC_SET_REC_TIMEOUT or by the kernel after setting the protocols.\r\n */\r\n#define LIRC_GET_REC_TIMEOUT           _IOR(\'i\', 0x00000024, __u32)\r\n\r\n/*\r\n * struct lirc_scancode - decoded scancode with protocol for use with\r\n *    LIRC_MODE_SCANCODE\r\n *\r\n * @timestamp: Timestamp in nanoseconds using CLOCK_MONOTONIC when IR\r\n *    was decoded.\r\n * @flags: should be 0 for transmit. When receiving scancodes,\r\n *    LIRC_SCANCODE_FLAG_TOGGLE or LIRC_SCANCODE_FLAG_REPEAT can be set\r\n *    depending on the protocol\r\n * @rc_proto: see enum rc_proto\r\n * @keycode: the translated keycode. Set to 0 for transmit.\r\n * @scancode: the scancode received or to be sent\r\n */\r\nstruct lirc_scancode {\r\n    __u64    timestamp;\r\n    __u16    flags;\r\n    __u16    rc_proto;\r\n    __u32    keycode;\r\n    __u64    scancode;\r\n};\r\n\r\n/* Set if the toggle bit of rc-5 or rc-6 is enabled */\r\n#define LIRC_SCANCODE_FLAG_TOGGLE    1\r\n/* Set if this is a nec or sanyo repeat */\r\n#define LIRC_SCANCODE_FLAG_REPEAT    2\r\nenum rc_proto {\r\n    RC_PROTO_UNKNOWN    = 0,\r\n    RC_PROTO_OTHER        = 1,\r\n    RC_PROTO_RC5        = 2,\r\n    RC_PROTO_RC5X_20    = 3,\r\n    RC_PROTO_RC5_SZ        = 4,\r\n    RC_PROTO_JVC        = 5,\r\n    RC_PROTO_SONY12        = 6,\r\n    RC_PROTO_SONY15        = 7,\r\n    RC_PROTO_SONY20        = 8,\r\n    RC_PROTO_NEC        = 9,\r\n    RC_PROTO_NECX        = 10,\r\n    RC_PROTO_NEC32        = 11,\r\n    RC_PROTO_SANYO        = 12,\r\n    RC_PROTO_MCIR2_KBD    = 13,\r\n    RC_PROTO_MCIR2_MSE    = 14,\r\n    RC_PROTO_RC6_0        = 15,\r\n    RC_PROTO_RC6_6A_20    = 16,\r\n    RC_PROTO_RC6_6A_24    = 17,\r\n    RC_PROTO_RC6_6A_32    = 18,\r\n    RC_PROTO_RC6_MCE    = 19,\r\n    RC_PROTO_SHARP        = 20,\r\n    RC_PROTO_XMP        = 21,\r\n    RC_PROTO_CEC        = 22,\r\n    RC_PROTO_IMON        = 23,\r\n    RC_PROTO_RCMM12        = 24,\r\n    RC_PROTO_RCMM24        = 25,\r\n    RC_PROTO_RCMM32        = 26,\r\n    RC_PROTO_XBOX_DVD    = 27,\r\n};\r\n\r\n#define NEC_NBITS        32\r\n#define NEC_UNIT        562500  /* ns */\r\n#define NEC_HEADER_PULSE    (16 * NEC_UNIT) /* 9ms */\r\n#define NECX_HEADER_PULSE    (8  * NEC_UNIT) /* Less common NEC variant */\r\n#define NEC_HEADER_SPACE    (8  * NEC_UNIT) /* 4.5ms */\r\n#define NEC_REPEAT_SPACE    (4  * NEC_UNIT) /* 2.25ms */\r\n#define NEC_BIT_PULSE        (1  * NEC_UNIT)\r\n#define NEC_BIT_0_SPACE        (1  * NEC_UNIT)\r\n#define NEC_BIT_1_SPACE        (3  * NEC_UNIT)\r\n#define    NEC_TRAILER_PULSE    (1  * NEC_UNIT)\r\n#define    NEC_TRAILER_SPACE    (10 * NEC_UNIT) /* even longer in reality */\r\n\r\n#define NS_TO_US(nsec)        ((nsec) / 1000)\r\n\r\n#define GPIO_IR_RAW_BUF_SIZE    128\r\n#define DEFAULT_CARRIER_FREQ    38000\r\n#define DEFAULT_DUTY_CYCLE    33\r\n#define NEC_ADDR_SHIFT        24\r\n#define NEC_UNADDR_SHIFT    16\r\n#define NEC_CMD_SHIFT        8\r\n#define NEC_UNCMD_SHIFT        0\r\n#define NEC_ENCODE_MASK        0xff\r\n#define RAW_MASK        0xffffff\r\n#define VERSION_NUM        256\r\n#define RAW_BANK        8\r\n#define SHIFT_MASK        8\r\n\r\nuint32_t rx_raw_buf[GPIO_IR_RAW_BUF_SIZE];\r\nuint32_t tx_raw_buf[GPIO_IR_RAW_BUF_SIZE];\r\n\r\nstatic int fd;\r\nstatic int fd1;\r\nstruct pollfd poll_fds[1];\r\nstatic int int_exit;\r\nstatic int kernel_flag;\r\npthread_t tid;\r\n\r\nstatic void print_usage(const char *argv0)\r\n{    printf("usage: %s [options]\\n", argv0);\r\n    printf("\\n");\r\n    printf("gpio ir receive test:\\n");\r\n    printf("\\tgpio_ir_test rx\\n");\r\n    printf("\\n");\r\n    printf("gpio ir send test:\\n");\r\n    printf("\\tgpio_ir_test tx <code>\\n");\r\n    printf("\\n");\r\n    printf("gpio ir loop test, rx&tx:\\n");\r\n    printf("\\tgpio_ir_test loop\\n");\r\n    printf("\\n");\r\n}\r\n\r\nstatic int nec_modulation_byte(uint32_t *buf, uint8_t code)\r\n{\r\n    int i = 0;\r\n    uint8_t mask = 0x01;\r\n\r\n    while (mask) {\r\n        /*low bit first*/\r\n        if (code & mask) {\r\n            /*bit 1*/\r\n            *(buf + i) = LIRC_PULSE(NS_TO_US(NEC_BIT_PULSE));\r\n            *(buf + i + 1) = LIRC_SPACE(NS_TO_US(NEC_BIT_1_SPACE));\r\n        } else {\r\n            /*bit 0*/\r\n            *(buf + i) = LIRC_PULSE(NS_TO_US(NEC_BIT_PULSE));\r\n            *(buf + i + 1) = LIRC_SPACE(NS_TO_US(NEC_BIT_0_SPACE));\r\n        }\r\n        mask <<= 1;\r\n        i += 2;\r\n    }\r\n    return i;\r\n}\r\n\r\nstatic int nec_ir_encode(uint32_t *raw_buf, uint32_t key_code)\r\n{\r\n    uint8_t address, not_address, command, not_command;\r\n    uint32_t *head_p, *data_p, *stop_p;\r\n\r\n    address    = (key_code >> NEC_ADDR_SHIFT) & NEC_ENCODE_MASK;\r\n    not_address = (key_code >> NEC_UNADDR_SHIFT) & NEC_ENCODE_MASK;\r\n    command    = (key_code >>  NEC_CMD_SHIFT) & NEC_ENCODE_MASK;\r\n    not_command = (key_code >>  NEC_UNCMD_SHIFT) & NEC_ENCODE_MASK;\r\n\r\n    /*head bit*/\r\n    head_p = raw_buf;\r\n    *(head_p) = LIRC_PULSE(NS_TO_US(NEC_HEADER_PULSE));\r\n    *(head_p + 1) = LIRC_SPACE(NS_TO_US(NEC_HEADER_SPACE));\r\n\r\n    /*data bit*/\r\n    data_p = raw_buf + 2;\r\n    nec_modulation_byte(data_p,  address);\r\n\r\n    data_p += 16;\r\n    nec_modulation_byte(data_p,  not_address);\r\n\r\n    data_p += 16;\r\n    nec_modulation_byte(data_p,  command);\r\n\r\n    data_p += 16;\r\n    nec_modulation_byte(data_p,  not_command);\r\n\r\n    /*stop bit*/\r\n    stop_p = data_p + 16;\r\n    *(stop_p) = LIRC_PULSE(NS_TO_US(NEC_TRAILER_PULSE));\r\n    *(stop_p + 1) = LIRC_SPACE(NS_TO_US(NEC_TRAILER_SPACE));\r\n\r\n    /*return the total size of nec protocal pulse*/\r\n    /* linux-5.4 needs 67 byte datas */\r\n    if (kernel_flag == 1)\r\n        return ((NEC_NBITS + 2) * 2 - 1);\r\n    else\r\n        return ((NEC_NBITS + 2) * 2);\r\n}\r\n\r\nvoid *ir_recv_thread(void *arg)\r\n{\r\n    int size = 0, size_t = 0;\r\n    int i = 0;\r\n    int dura;\r\n    int ret;\r\n    int total = 0;\r\n\r\n    poll_fds[0].fd = fd;\r\n    poll_fds[0].events = POLLIN | POLLERR;\r\n    poll_fds[0].revents = 0;\r\n    while (!int_exit) {\r\n        ret = poll(poll_fds, 1, 12);\r\n        if (!ret) {\r\n            printf("\\n--------------------\\n");\r\n            total = 0;\r\n        } else {\r\n            if (poll_fds[0].revents == POLLIN) {\r\n                size = read(fd, (char *)(rx_raw_buf),\r\n                        GPIO_IR_RAW_BUF_SIZE);\r\n                size_t = size / sizeof(uint32_t);\r\n                for (i = 0; i < size_t; i++) {\r\n                    dura = rx_raw_buf[i] & RAW_MASK;\r\n                    printf("%d ", dura);\r\n                    if ((total++) % RAW_BANK == 0)\r\n                        printf("\\n");\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return NULL;\r\n}\r\n\r\nvoid gpio_ir_test_close(int sig)\r\n{\r\n    /* allow the stream to be closed gracefully */\r\n    signal(sig, SIG_IGN);\r\n    int_exit = 1;\r\n    if (fd1 != fd)\r\n        close(fd1);\r\n    close(fd);\r\n}\r\n\r\nint main(int argc, char **argv)\r\n{\r\n    int ret;\r\n    int size = 0, size_t = 0;\r\n    int i = 0;\r\n    int duty_cycle;\r\n    int carrier_freq;\r\n    int key_code = 0;\r\n    int err = 0;\r\n    int cnt = 0;\r\n    /* use for check the current kernel version */\r\n    int fd_version;\r\n    char version_buf[VERSION_NUM];\r\n\r\n    fd_version = open("/proc/version", O_RDONLY);\r\n    if (fd_version < 0) {\r\n        printf("The system is not mount proc, please check\\n");\r\n        return -1;\r\n    }\r\n    ret = read(fd_version, version_buf, sizeof(version_buf));\r\n    if (ret < 0) {\r\n        printf("Can\'t not read /proc/verison\\n");\r\n        return -1;\r\n    }\r\n    switch(version_buf[14]) {\r\n        case \'4\':\r\n            kernel_flag = 0;\r\n            printf("This is 4.* linux kernel\\n");\r\n            break;\r\n        case \'5\':\r\n            kernel_flag = 1;\r\n            printf("This is 5.* linux kernel\\n");\r\n            break;\r\n        default:\r\n            kernel_flag = 0;\r\n            printf("This is %c.* kernel which is not support\\n", version_buf[14]);\r\n            break;\r\n    }\r\n    close(fd_version);\r\n\r\n    /* catch ctrl-c to shutdown cleanly */\r\n    signal(SIGINT, gpio_ir_test_close);\r\n\r\n    if (argc < 2) {\r\n        print_usage(argv[0]);\r\n        return -1;\r\n    }\r\n\r\n    fd = open("/dev/lirc0", O_RDWR);\r\n    if (fd < 0) {\r\n        printf("can\'t open lirc0 recv, check driver!\\n");\r\n        return 0;\r\n    } else {\r\n        printf("lirc0 open succeed.\\n");\r\n    }\r\n\r\n    fd1 = open("/dev/lirc1", O_RDWR);\r\n    if (fd1 < 0) {\r\n        printf("can\'t open lirc1 send, check driver!\\n");\r\n        fd1 = fd;\r\n        printf("There is no lirc1, use the lirc0 as lirc1.\\n");\r\n    } else {\r\n        printf("lirc1 open succeed.\\n");\r\n    }\r\n\r\n    for (i = 1; i < argc; i++) {\r\n        if (!strcmp(argv[i], "-n")) {\r\n            if (i + 1 >= argc) {\r\n                printf("Option -n expects an argument.\\n\\n");\r\n                print_usage(argv[0]);\r\n                goto OUT;\r\n            }\r\n            continue;\r\n        }\r\n    }\r\n\r\n    if (!strcmp(argv[1], "rx")) {\r\n        err = pthread_create(&tid, NULL, (void *)ir_recv_thread, NULL);\r\n        if (err != 0) {\r\n            printf("create pthread error: %d\\n", __LINE__);\r\n            goto OUT;\r\n        }\r\n\r\n        do {\r\n            usleep(1000);\r\n        } while (!int_exit);\r\n\r\n    } else if (!strcmp(argv[1], "tx")) {\r\n        if (argc < 3) {\r\n            fprintf(stderr, "No data passed\\n");\r\n            goto OUT;\r\n        }\r\n\r\n        if (sscanf(argv[2], "%x", &key_code) != 1) {\r\n            fprintf(stderr, "no input data: %s\\n", argv[2]);\r\n            goto OUT;\r\n        }\r\n\r\n        key_code = key_code << SHIFT_MASK;\r\n\r\n        duty_cycle = DEFAULT_DUTY_CYCLE;\r\n        if (ioctl(fd1, LIRC_SET_SEND_DUTY_CYCLE, &duty_cycle)) {\r\n            fprintf(stderr,\r\n                "lirc0: could not set carrier duty: %s\\n",\r\n                strerror(errno));\r\n            goto OUT;\r\n        }\r\n\r\n        if (sscanf(argv[3], "%ul", &carrier_freq) != 1) {\r\n            fprintf(stderr, "no input data: %s\\n", argv[3]);\r\n            goto OUT;\r\n        }\r\n\r\n        if (ioctl(fd1, LIRC_SET_SEND_CARRIER, &carrier_freq)) {\r\n            fprintf(stderr,\r\n                "lirc0: could not set carrier freq: %s\\n",\r\n                strerror(errno));\r\n            goto OUT;\r\n        }\r\n\r\n        printf("irtest: send key code : 0x%x\\n", key_code);\r\n\r\n        size = nec_ir_encode(tx_raw_buf, key_code);\r\n        /*dump the raw data*/\r\n        for (i = 0; i < size; i++) {\r\n            printf("%d ", *(tx_raw_buf + i) & RAW_MASK);\r\n            if ((i + 1) % RAW_BANK == 0)\r\n                printf("\\n");\r\n        }\r\n        printf("\\n");\r\n\r\n        /* linux-5.4 IR core should delete bit24~bit31 */\r\n        if (kernel_flag == 1) {\r\n            for (i = 0; i < size; i++) {\r\n                tx_raw_buf[i] = (tx_raw_buf[i] & RAW_MASK);\r\n            }\r\n        }\r\n\r\n        if (argc > 4 && !strcmp(argv[3], "-n")) {\r\n                        cnt = atoi(argv[4]);\r\n                        for (i = 0; i < cnt; i++) {\r\n                                size_t = size * sizeof(uint32_t);\r\n                                ret = write(fd1, (char *)tx_raw_buf, size_t);\r\n                                if (ret > 0)\r\n                                        printf("irtest No.%d: send %d bytes ir raw data\\n\\n",\r\n                                                i, ret);\r\n                else\r\n                    printf("irtest No.%d: send %d failed!\\n", i, ret);\r\n                usleep(100*1000);\r\n                        }\r\n                } else {\r\n            size_t = size * sizeof(uint32_t);\r\n            ret = write(fd1, (char *)tx_raw_buf, size_t);\r\n            if (ret > 0)\r\n                printf("irtest: send %d bytes ir raw data\\n\\n", ret);\r\n            else\r\n                printf("irtest: send %d failed\\n", ret);\r\n        }\r\n\r\n    } else if (!strcmp(argv[1], "loop")) {\r\n\r\n        /*code: 0x13*/\r\n        key_code = 0x04fb13ec;\r\n        err = pthread_create(&tid, NULL, (void *)ir_recv_thread, NULL);\r\n        if (err != 0) {\r\n            printf("create pthread error: %d\\n", __LINE__);\r\n            goto OUT;\r\n        }\r\n\r\n        duty_cycle = DEFAULT_DUTY_CYCLE;\r\n        if (ioctl(fd1, LIRC_SET_SEND_DUTY_CYCLE, &duty_cycle)) {\r\n            fprintf(stderr,\r\n                "lirc0: could not set carrier duty: %s\\n",\r\n                strerror(errno));\r\n            goto OUT;\r\n        }\r\n        carrier_freq = DEFAULT_CARRIER_FREQ;\r\n        if (ioctl(fd1, LIRC_SET_SEND_CARRIER, &carrier_freq)) {\r\n            fprintf(stderr,\r\n                "lirc0: could not set carrier freq: %s\\n",\r\n                strerror(errno));\r\n            goto OUT;\r\n        }\r\n\r\n        /*echo 50ms transmit one frame */\r\n\r\n        if (argc > 3 && !strcmp(argv[2], "-n")) {\r\n            cnt = atoi(argv[3]);\r\n            for (i = 0; i < cnt; i++) {\r\n                size = nec_ir_encode(tx_raw_buf, key_code);\r\n                size_t = size * sizeof(uint32_t);\r\n                /* linux-5.4 IR core should delete bit24~bit31 */\r\n                if (kernel_flag == 1) {\r\n                    for (i = 0; i < size; i++) {\r\n                        tx_raw_buf[i] = (tx_raw_buf[i] & RAW_MASK);\r\n                    }\r\n                }\r\n                printf("send key code : 0x%x, No.%d\\n", key_code, i);\r\n                write(fd1, (char *)tx_raw_buf, size_t);\r\n                usleep(100*1000);\r\n                if (int_exit)\r\n                    break;\r\n            }\r\n                } else {\r\n                        i = 0;\r\n            do {\r\n                size = nec_ir_encode(tx_raw_buf, key_code);\r\n                size_t = size * sizeof(uint32_t);\r\n                /* linux-5.4 IR core should delete bit24~bit31 */\r\n                if (kernel_flag == 1) {\r\n                    for (i = 0; i < size; i++) {\r\n                        tx_raw_buf[i] = (tx_raw_buf[i] & RAW_MASK);\r\n                    }\r\n                }\r\n                printf("send key code : 0x%x, %d\\n", key_code, i++);\r\n                write(fd1, (char *)tx_raw_buf, size_t);\r\n                usleep(100*1000);\r\n            } while (!int_exit);\r\n        }\r\n    } else if (!strcmp(argv[1], "-n")) {\r\n        print_usage(argv[0]);\r\n    }\r\n\r\nOUT:\r\n    if (fd1 != fd)\r\n        close(fd1);\r\n    close(fd);\r\n    return 0;\r\n}\n'})})]})}function C(n={}){const{wrapper:r}={...(0,i.a)(),...n.components};return r?(0,_.jsx)(r,{...n,children:(0,_.jsx)(o,{...n})}):o(n)}},96435:(n,r,e)=>{e.d(r,{Z:()=>_});const _=e.p+"assets/images/image-20240401233043036-d15440bea6099944c5b5192a0c4960a4.png"},689:(n,r,e)=>{e.d(r,{Z:()=>_});const _=e.p+"assets/images/image-20240401233113163-137fedd7796869baede33f9afaf49429.png"},11151:(n,r,e)=>{e.d(r,{Z:()=>s,a:()=>d});var _=e(67294);const i={},t=_.createContext(i);function d(n){const r=_.useContext(t);return _.useMemo((function(){return"function"==typeof n?n(r):{...r,...n}}),[r,n])}function s(n){let r;return r=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:d(n.components),_.createElement(t.Provider,{value:r},n.children)}}}]);